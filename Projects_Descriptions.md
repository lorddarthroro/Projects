**Projects**
**My Computer Science/ Data Science Projects**

**HuffmanEncoderAndDecoder** - This is a project I did for my Computer Science Data Structures and Algorithms Class. It reads in a text file, byte by byte, and uses Huffman Compression to generate a coded file (a .enc file). To explain the way the compression works simply, it reads in characters, and uses an array of size 256 (the number of possible  characters) to store the frequency of each character. Then, the elements in the frequency table are stored as nodes, which are put into a priority queue, which compares the frequencies and orders the characters accordingly. It then constructs a binary tree using those nodes, such that each leaf of the tree is a node. Thus, when accessing characters in the tree, the encoder traverses the tree, adding "1's" for right traversal and "0's" for left traversal. The generate huffman codes are then stored in a hashmap, such that the next tme the file is read trhough, the corresponding codes are found easily and efficiently. Then, it writes the huffman codes to the output file, using "trues" as 1 and "falses" and 0 (boolean compress nicer then integers). Additionally, the code creates a file called "freq file" that holds characters (given by their binary values) and their frequencies, which is necessary for the decoder to work. The decoder reads in this file, and uses the frequencies and characters to reconstruct the huffman tree, which it can use to "decode" the file by comparing the 1's and 0's read in (trues sand falses) and uses this huffman tree to make a decoding hashmap. This hashmap stores the huffman code with its corresponding characters. The decoder then simply reads in the 0’s and 1’s and generates a string with them, comparing the string to the hashmap on every step. Once it finds a match, it can output the corresponding character to the output file, and then continue on to decode the next set of numbers. It’s important to note, not all of the classes in the code are entirely my own. This was for a project for a computer science class I took, and we were allowed to use the given Huffman Interface, BinaryIn, and BinaryOut classes. The BinaryIn and BinaryOut were obtained by our professor from another source (the file credits the authors above where the class is implemented). 

**Sudoku Solver** - This is a project I did for fun when trying to self-teach python. The way the sudoku is imputed isn’t super user friendly, which is something I might go back and improve on. Essentially, you enter the unsolved sudoku as a 2D array (array of arrays) with 0’s representing empty boxes. Most of the code’s methods are pretty self-explanatory, so I’ll briefly explain the most complicated part, which is the algorithm the program uses to actually solve the puzzle: backtracking. The backtracking algorithm is a recursive algorithm that works by constantly trying a value for a box, and every time the sudoku puzzle's current configuration is found to be valid (no row, column, or 3x3 box conflicts) it continues to call the algorithm on the next box of the sudoku. It continues to do this, and when it finds invalud placement, it pauses calling itself, and instead “goes back” and tries replacing the previous box’s number. Once the algorithm finds the board is completely solved (no 0’s and no conflicts in rows, columns, 3x3 boxes), it returns “true” and stops modifying the board, meaning the board is now solved. The program doesn’t have a catch case to catch impossible sudokus, though I might look to implement that in the future. 

